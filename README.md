## Тьюториал: Создание приложения для конвертации валюты и биткоина

В этом тьюториале мы создадим простое приложение на языке Python с использованием Flask. Приложение будет позволять конвертировать сумму в указанной валюте в биткоины, используя данные из стороннего API. При этом в процессе работы будем использовать TDD (Test driven development).

### Шаг 1: Описание проекта

У вас уже создана основа проекта и она выполняется в виртуальном окружении в github codespaces.
Также уже установлены фреймворк Flask и библиотека requests и фреймворк для тестирования pytest. 
Чтобы посмотреть версии и список библиотек см файл requirements.txt

Папки для вашего проекта Flask настроены следующим образом, обратите внимание, для тестов, шаблонов и кода приложения используются отдельные каталоги:

```
project/
    ├── app/
    │   ├── __init__.py
    │   ├── converter.py
    │   └── routes.py
    ├── tests/
    │   ├── __init__.py
    │   └── test_converter.py
    ├── templates/
    │   ├── index.html
    │   └── result.html
    ├── requirements.txt
    ├── .gitignore
    └── run.py
```

Вот описание структуры папок:

- `app/`: В этой папке содержится основной код приложения.
  - `__init__.py`: Этот файл отмечает папку `app/` как пакет Python.
  - `converter.py`: В этом файле содержится класс `Converter` (Конвертер).
  - `routes.py`: В этом файле содержатся маршруты Flask и логика приложения.

- `tests/`: В этой папке содержатся файлы тестов для вашего приложения.
  - `__init__.py`: Этот файл отмечает папку `tests/` как пакет Python.
  - `test_converter.py`: В этом файле содержатся модульные тесты для класса `Converter` (Конвертер).

- `templates/`: В этой папке содержатся HTML-шаблоны для отображения веб-страниц.

- `requirements.txt`: В этом файле перечислены зависимости вашего проекта, включая Flask и другие необходимые пакеты. Вы можете использовать команду `pip freeze`, чтобы сгенерировать этот файл.

- `.gitignore`: В этом файле указываются файлы и папки, которые должны быть проигнорированы системой контроля версий Git. Вы можете включить `venv/` (если вы используете виртуальное окружение) и другие сгенерированные файлы.

- `run.py`: В этом файле находится точка входа вашего приложения, где создается и запускается Flask-приложение.

### Шаг 2: Написание кода

Теперь давайте напишем код для нашего приложения, используя TDD. Для этого написание кода конвертера начинается с написания спецификаций и сразу теста для кода (до самого кода который этот тест будет выполнять). 

В проекте уже сделаны заготовки для класса конвертера и его юнит-тестов.

Тест можно разбить на 3 этапа: подготовка, проверяемое действие и проверка результата. Подготовка это инициализация класса, действие вызов метода get_exchange_rate, а проверка осуществляется с помощью assert, который просто сверяет ожидаемый результат с полученным из нашего метода.

Декоратор @pytest.fixture используется чтобы определить фикстуру (fixture) - функцию, которая предоставляет фиксированный набор данных или ресурсов для одной или нескольких тестовых функций. Когда тестовая функция включает параметр, аннотированный именем функции-фикстуры, pytest автоматически вызывает функцию-фикстуру и предоставляет возвращаемое значение в качестве аргумента для тестовой функции. Так выполнена подготовка теста.

```
exchange_rate = converter.get_exchange_rate('USD')
assert exchange_rate == 100
```
Написав данный код, мы ожидаем что наш код будет возвращать курс равный 100, если мы указали доллары.

Запустим тест выполнив команду pytest. Фреймворк сам обнаружит все тест кейсы и выполнит их (пока наш один кейс). И конечно он должен провалиться.

Следующий шаг написать минимальное количество кода, чтобы тест проходил проверку.

```
return 100
```

Отлично тест выполняется. Пока рефакторинг не требуется, значит снова делаем первый шаг - создать новый тест (новая функция), который будет проваливаться.

Теперь по аналогии напишите используя TDD тесты для проверки курса функтов стерлингов(GBP) и евро (EUR). Курс функтов примем равным 200, а евро 300. Теперь вам уже понадобится рефакторинг. Также проведите такие же циклы для convert_bitcoins.

### Шаг 3. Делаем параметрические тесты 

В PyTest параметризация тестов позволяет определить набор входных параметров и ожидаемых результатов для тестовой функции с использованием декоратора @pytest.mark.parametrize. PyTest автоматически генерирует и выполняет отдельные тестовые случаи для каждой комбинации параметров.

Это позволит нам объеденить одинаковые по сути тесты, когда они отличаются только наборами данных. Выполним рефакторинг наших тестов вот так

```
@pytest.mark.parametrize("currency, result", [
    ("USD", 100),
    ("GBR", 200),
    ("EUR", 300)
])
def test_return_exchange_rate(converter, currency, result):
    # Test the get_exchange_rate method
    exchange_rate = converter.get_exchange_rate(currency)
    assert exchange_rate == result
```

В приведенном примере, функция test_return_exchange_rate декорирована с помощью @pytest.mark.parametrize, указывая входные параметры (валюту) и ожидаемый вывод (результат). При выполнении команды pytest, она будет выполняться несколько раз, каждый раз с различным набором входных параметров, определенных в декораторе parametrize.

Таким образом, PyTest автоматически создает и выполняет отдельные тестовые случаи для каждой комбинации входных параметров, что позволяет удобно проверять различные варианты входных данных и убеждаться в правильности работы тестовой функции.

Произведите рефакторинг и для тестов функции convert_bitcoins.

### Шаг 4. Тестирование API
Но конечно, нам не подходят фальшивые значения валют. Как же быть с тестами, ведь мы подключая api создаем сторонние зависимости. Для юнит-тестирования таких ситуаций используют mock. Pytest содержит monkeypatch для подмены функции requests.get.

Monkeypatching - это техника, которая позволяет временно изменять поведение функций, атрибутов или переменных во время выполнения тестов. Это полезно, когда вам нужно создать имитацию или подменить какую-либо функциональность, чтобы протестировать определенные сценарии.

В случае pytest, фреймворк предоставляет встроенную фикстуру под названием "monkeypatch", которая упрощает monkeypatching ваших тестов.

Преимущество monkeypatch заключается в том, что вы можете временно изменить поведение функции или атрибута без изменения исходного кода. Например, вы можете имитировать результат функции, подменить значение переменной или изменить атрибут класса.

Для использования monkeypatch в вашем тесте, вам необходимо включить его в качестве параметра в тестовую функцию. Затем вы можете использовать методы monkeypatch для внесения изменений.

Например, если вам нужно имитировать результат функции requests.get, вы можете создать собственную функцию-имитацию и использовать monkeypatch.setattr для замены оригинальной функции на вашу имитацию. Таким образом, во время выполнения теста будет вызываться ваша имитация вместо оригинальной функции.

```
def test_convert_bitcoins_with_mocked_api(converter, monkeypatch):

    # Mock the requests.get function using monkeypatch
    def mock_get(url):
        class MockResponse:
            def __init__(self, json_data):
                self.json_data = {"time":{"updated":"May 24, 2023 21:59:00 UTC","updatedISO":"2023-05-24T21:59:00+00:00","updateduk":"May 24, 2023 at 22:59 BST"},"disclaimer":"This data was produced from the CoinDesk Bitcoin Price Index (USD). Non-USD currency data converted using hourly conversion rate from openexchangerates.org","chartName":"Bitcoin","bpi":{"USD":{"code":"USD","symbol":"&#36;","rate":"26,356.1900","description":"United States Dollar","rate_float":26356.19},"GBP":{"code":"GBP","symbol":"&pound;","rate":"22,023.0215","description":"British Pound Sterling","rate_float":22023.0215},"EUR":{"code":"EUR","symbol":"&euro;","rate":"25,674.7771","description":"Euro","rate_float":25674.7771}}}

            
            def json(self):
                return self.json_data
    
        return MockResponse(mock_response)

    monkeypatch.setattr(requests, "get", mock_get)

    # Test the convert_bitcoins method
    converted_amount = converter.convert_bitcoins("USD", 100)
    assert converted_amount == 2635619.000000
```

В этом коде взят фиксированный синтаксически верный ответ от api и создан искусственный класс ответа сервера с этим фиксированным значением. На него мы подменяем результат get. В итоге мы можем точно сказать какой ответ конвертера будет правильным, поскольку знаем значения вернувшиеся на запрос.

Однако нам теперь неоходимо дописать основной код, чтобы наш тест не падал. Запрос к api и разбор ответа будет выглядеть так:

```
url = 'https://api.coindesk.com/v1/bpi/currentprice.json'
response = requests.get(url)
data = response.json()
return float(data['bpi'][currency]['rate_float'])
```

Теперь время рефакторинга, пересмотрите как теперь выглядят тесты для разных валют и вариантов конвертации. Проверьте что выполняются все тесты.

А теперь давайте запустим наше приложение.
```
flask --debug run
```

Оно должно заработать сразу, потому что вы смогли отладить свой код без приввязки к интерфейсу, максимально абстрагировавшись от возможных ошибках в других частях приложения. Это и есть задача unit тестов.
